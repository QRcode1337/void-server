#!/bin/bash
# Pre-commit hook to scan for secrets in staged files
# Install: ./.githooks/install-hooks.sh

set -e

PROJECT_ROOT="$(git rev-parse --show-toplevel)"
PATTERNS_FILE="$PROJECT_ROOT/scripts/lib/secret-patterns.txt"
ALLOWLIST_FILE="$PROJECT_ROOT/config/secrets-allowlist.json"

# Colors
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m'

# Track findings
SECRETS_FOUND=0
declare -a FINDINGS

# Load allowlist patterns
load_allowlist() {
  ALLOWED_PATTERNS=""
  ALLOWED_FILES=""

  if [[ -f "$ALLOWLIST_FILE" ]] && command -v node &>/dev/null; then
    ALLOWED_PATTERNS=$(node -e "
      const fs = require('fs');
      const data = JSON.parse(fs.readFileSync('$ALLOWLIST_FILE', 'utf8'));
      const patterns = (data.patterns || []).map(p => p.pattern);
      console.log(patterns.join('|'));
    " 2>/dev/null) || ALLOWED_PATTERNS=""

    ALLOWED_FILES=$(node -e "
      const fs = require('fs');
      const data = JSON.parse(fs.readFileSync('$ALLOWLIST_FILE', 'utf8'));
      const files = (data.files || []).map(f => f.path);
      console.log(files.join('\n'));
    " 2>/dev/null) || ALLOWED_FILES=""
  fi
}

# Check if file is allowlisted
is_file_allowlisted() {
  local file="$1"

  if [[ -z "$ALLOWED_FILES" ]]; then
    return 1
  fi

  while IFS= read -r pattern; do
    [[ -z "$pattern" ]] && continue
    # Handle glob patterns
    case "$file" in
      $pattern) return 0 ;;
    esac
    # Handle ** patterns
    if [[ "$pattern" == **/* ]]; then
      local suffix="${pattern#**/}"
      [[ "$file" == *"$suffix" ]] && return 0
    fi
  done <<< "$ALLOWED_FILES"

  return 1
}

# Check if match is allowlisted
is_match_allowlisted() {
  local match="$1"

  if [[ -n "$ALLOWED_PATTERNS" ]]; then
    echo "$match" | grep -qE "$ALLOWED_PATTERNS" && return 0
  fi

  return 1
}

# Scan a file for secrets
scan_file() {
  local file="$1"

  # Get staged content (not working tree)
  local content
  content=$(git show ":$file" 2>/dev/null) || return 0

  # Skip binary files
  if echo "$content" | grep -q $'\x00'; then
    return 0
  fi

  # Skip allowlisted files
  if is_file_allowlisted "$file"; then
    return 0
  fi

  # Read patterns
  while IFS= read -r pattern; do
    # Skip comments and empty lines
    [[ "$pattern" =~ ^#.*$ ]] && continue
    [[ -z "$pattern" ]] && continue

    # Search for pattern
    local matches
    matches=$(echo "$content" | grep -nE "$pattern" 2>/dev/null) || continue

    while IFS= read -r match; do
      [[ -z "$match" ]] && continue

      # Extract line number and content
      local line_num="${match%%:*}"
      local line_content="${match#*:}"

      # Check allowlist
      is_match_allowlisted "$line_content" && continue

      # Truncate long matches for display
      if [[ ${#line_content} -gt 80 ]]; then
        line_content="${line_content:0:77}..."
      fi

      FINDINGS+=("$file:$line_num: $line_content")
      ((SECRETS_FOUND++))
    done <<< "$matches"

  done < "$PATTERNS_FILE"
}

# Format staged client files with Prettier
format_client() {
  # Check if any client files are staged
  local client_files
  client_files=$(git diff --cached --name-only --diff-filter=ACMR | grep "^client/src/" || true)

  if [[ -z "$client_files" ]]; then
    return 0
  fi

  echo ""
  echo "Formatting client files..."

  # Check if client node_modules exists
  if [[ ! -d "$PROJECT_ROOT/client/node_modules" ]]; then
    echo -e "${YELLOW}Skipping format: client dependencies not installed${NC}"
    return 0
  fi

  cd "$PROJECT_ROOT/client"

  # Format only staged files
  local files_to_format=""
  while IFS= read -r file; do
    # Remove client/ prefix for prettier
    local relative_file="${file#client/}"
    files_to_format="$files_to_format $relative_file"
  done <<< "$client_files"

  # Run prettier on staged files
  if npx prettier --write $files_to_format 2>/dev/null; then
    echo -e "${GREEN}Format complete${NC}"
    # Re-add formatted files to staging
    cd "$PROJECT_ROOT"
    echo "$client_files" | xargs git add
  else
    echo -e "${YELLOW}Format skipped (prettier error)${NC}"
    cd "$PROJECT_ROOT"
  fi
}

# Lint staged client files
lint_client() {
  # Check if any client files are staged
  local client_files
  client_files=$(git diff --cached --name-only --diff-filter=ACMR | grep "^client/src/" || true)

  if [[ -z "$client_files" ]]; then
    return 0
  fi

  echo ""
  echo "Linting client files..."

  # Check if client node_modules exists
  if [[ ! -d "$PROJECT_ROOT/client/node_modules" ]]; then
    echo -e "${YELLOW}Skipping lint: client dependencies not installed${NC}"
    return 0
  fi

  cd "$PROJECT_ROOT/client"
  if npm run lint 2>/dev/null; then
    echo -e "${GREEN}Lint passed!${NC}"
    cd "$PROJECT_ROOT"
    return 0
  fi

  echo ""
  echo -e "${RED}================================${NC}"
  echo -e "${RED}       LINT ERRORS FOUND        ${NC}"
  echo -e "${RED}================================${NC}"
  echo ""
  npm run lint 2>&1 | head -50
  echo ""
  echo -e "${YELLOW}Run 'cd client && npm run lint' for full output${NC}"
  echo ""
  echo -e "${RED}Commit blocked.${NC}"
  cd "$PROJECT_ROOT"
  exit 1
}

# Main
main() {
  # Run secrets scan
  echo "Scanning for secrets..."

  # Check if patterns file exists
  if [[ ! -f "$PATTERNS_FILE" ]]; then
    echo -e "${YELLOW}Warning: Secret patterns file not found${NC}"
    echo "Expected: $PATTERNS_FILE"
  else
    # Load allowlist
    load_allowlist

    # Get list of staged files
    local staged_files
    staged_files=$(git diff --cached --name-only --diff-filter=ACMR)

    if [[ -n "$staged_files" ]]; then
      # Scan each file
      while IFS= read -r file; do
        scan_file "$file"
      done <<< "$staged_files"

      # Report findings
      report_secrets
    fi
  fi

  # Format and lint client files
  format_client
  lint_client

  exit 0
}

# Report secret findings
report_secrets() {
  if [[ $SECRETS_FOUND -gt 0 ]]; then
    echo ""
    echo -e "${RED}================================${NC}"
    echo -e "${RED}  POTENTIAL SECRETS DETECTED!   ${NC}"
    echo -e "${RED}================================${NC}"
    echo ""
    echo "Found $SECRETS_FOUND potential secret(s) in staged files:"
    echo ""

    for finding in "${FINDINGS[@]}"; do
      echo -e "  ${YELLOW}$finding${NC}"
    done

    echo ""
    echo "Options:"
    echo "  1. Remove the secrets from your code"
    echo "  2. Add to allowlist: config/secrets-allowlist.json"
    echo "  3. Bypass (NOT recommended): git commit --no-verify"
    echo ""
    echo -e "${RED}Commit blocked.${NC}"
    exit 1
  fi

  echo -e "${GREEN}No secrets detected.${NC}"
}

main "$@"
