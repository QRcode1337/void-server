/**
 * Vite Plugin: Discover Plugins
 *
 * Scans plugin directories at build time and generates a virtual module
 * that exports all plugin client components for dynamic loading.
 *
 * Usage in code:
 *   import { pluginModules } from 'virtual:plugins';
 *   const PluginComponent = pluginModules['void-plugin-verify'];
 */

import fs from 'fs';
import path from 'path';

const VIRTUAL_MODULE_ID = 'virtual:plugins';
const RESOLVED_VIRTUAL_MODULE_ID = '\0' + VIRTUAL_MODULE_ID;

export default function discoverPlugins(options = {}) {
  // Support both single dir (legacy) and array of dirs
  const pluginsDirs = options.pluginsDirs || (
    options.pluginsDir
      ? [options.pluginsDir]
      : [path.resolve(process.cwd(), '../plugins')]
  );

  // Track discovered plugins for manifest generation
  let discoveredPlugins = [];

  return {
    name: 'discover-plugins',

    resolveId(id) {
      if (id === VIRTUAL_MODULE_ID) {
        return RESOLVED_VIRTUAL_MODULE_ID;
      }
    },

    load(id) {
      if (id !== RESOLVED_VIRTUAL_MODULE_ID) return null;

      // Scan all plugin directories
      const plugins = [];
      const seenNames = new Set();

      for (const pluginsDir of pluginsDirs) {
        if (!fs.existsSync(pluginsDir)) continue;

        const entries = fs.readdirSync(pluginsDir, { withFileTypes: true });

        for (const entry of entries) {
          if (!entry.name.startsWith('void-plugin-')) continue;
          // Skip duplicates (core plugins take precedence)
          if (seenNames.has(entry.name)) continue;

          const pluginPath = path.join(pluginsDir, entry.name);
          let realPath = pluginPath;

          // Follow symlinks
          if (fs.lstatSync(pluginPath).isSymbolicLink()) {
            realPath = fs.realpathSync(pluginPath);
          }

          // Check if it's a valid plugin with client entry
          const manifestPath = path.join(realPath, 'manifest.json');
          if (!fs.existsSync(manifestPath)) continue;

          const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));
          const clientEntry = manifest.client?.entry;

          if (!clientEntry) continue;

          const clientEntryPath = path.join(realPath, clientEntry);
          if (!fs.existsSync(clientEntryPath)) continue;

          plugins.push({
            name: entry.name,
            clientEntry: clientEntryPath,
            manifest,
            isUserPlugin: pluginsDir.includes('data/plugins') || pluginsDir.includes('data\\plugins')
          });
          seenNames.add(entry.name);
        }
      }

      // Store for manifest generation
      discoveredPlugins = plugins;

      // Generate the virtual module code
      const imports = plugins.map((p, i) =>
        `import * as plugin${i} from '${p.clientEntry.replace(/\\/g, '/')}';`
      ).join('\n');

      const moduleMap = plugins.map((p, i) =>
        `  '${p.name}': plugin${i}`
      ).join(',\n');

      const manifestMap = plugins.map(p =>
        `  '${p.name}': ${JSON.stringify(p.manifest)}`
      ).join(',\n');

      const code = `
// Auto-generated by vite-plugin-discover-plugins
// Do not edit manually

${imports}

export const pluginModules = {
${moduleMap}
};

export const pluginManifests = {
${manifestMap}
};

export const pluginNames = ${JSON.stringify(plugins.map(p => p.name))};
`;

      return code;
    },

    // Trigger rebuild when plugins directory changes (dev mode)
    configureServer(server) {
      // Watch all plugin directories
      for (const dir of pluginsDirs) {
        if (fs.existsSync(dir)) {
          server.watcher.add(dir);
        }
      }

      server.watcher.on('all', (event, filePath) => {
        // Only reload on source file changes, not data files
        const isSourceFile = filePath.endsWith('.js') ||
                            filePath.endsWith('.jsx') ||
                            filePath.endsWith('.ts') ||
                            filePath.endsWith('.tsx') ||
                            filePath.endsWith('.css') ||
                            filePath.endsWith('manifest.json');
        // Exclude plugin data directories and node_modules
        const isDataFile = filePath.includes('/data/') && !pluginsDirs.some(d => filePath.startsWith(d)) ||
                          filePath.includes('\\data\\') && !pluginsDirs.some(d => filePath.startsWith(d)) ||
                          filePath.includes('node_modules');

        const isInPluginDir = pluginsDirs.some(dir => filePath.includes(dir));

        if (isInPluginDir && isSourceFile && !isDataFile) {
          // Invalidate the virtual module to trigger re-generation
          const mod = server.moduleGraph.getModuleById(RESOLVED_VIRTUAL_MODULE_ID);
          if (mod) {
            server.moduleGraph.invalidateModule(mod);
            server.ws.send({ type: 'full-reload' });
          }
        }
      });
    },

    // Write plugin manifest to dist for server-side validation
    writeBundle(outputOptions) {
      const outDir = outputOptions.dir || path.resolve(process.cwd(), 'dist');
      const manifestPath = path.join(outDir, '.plugin-manifest.json');

      const manifest = {
        buildTime: new Date().toISOString(),
        plugins: discoveredPlugins.map(p => ({
          name: p.name,
          isUserPlugin: p.isUserPlugin
        }))
      };

      fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 2));
    }
  };
}
